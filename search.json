[{"title":"STM32H7指定从外部Flash启动程序","url":"/2024/09/27/STM32H7%E6%8C%87%E5%AE%9A%E4%BB%8E%E5%A4%96%E9%83%A8Flash%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/","content":"STM32H7指定从外部Flash启动程序代码启动流程单片机默认上电之后会从0x80000000处开始执行代码，也就是从内部flash启动。首先我们来看启动流程。\n在开始之前，首先得确保你可以找得到.s文件，比如startup_stm32h7b0xx.s，这个文件是启动文件，在STM32CubeMX生成的代码中，这个文件位于MDK_ARM目录下。\n然后，找到如下代码：\n__Vectors       DCD     __initial_sp                      ; Top of Stack                DCD     Reset_Handler                     ; Reset Handler                DCD     NMI_Handler                       ; NMI Handler                DCD     HardFault_Handler                 ; Hard Fault Handler                DCD     MemManage_Handler                 ; MPU Fault Handler                DCD     BusFault_Handler                  ; Bus Fault Handler                DCD     UsageFault_Handler                ; Usage Fault Handler                DCD     0                                 ; Reserved                DCD     0                                 ; Reserved                DCD     0                                 ; Reserved                DCD     0                                 ; Reserved                DCD     SVC_Handler                       ; SVCall Handler                DCD     DebugMon_Handler                  ; Debug Monitor Handler                DCD     0                                 ; Reserved                DCD     PendSV_Handler                    ; PendSV Handler                DCD     SysTick_Handler                   ; SysTick Handler\n\n\n__Vectors就是启动文件中定义的向量表，也就是中断向量表，在程序启动时，会根据这个向量表来跳转到相应的函数。\nDCD指令定义一个32位的常量，这里定义了中断向量表中的各个中断处理函数的入口地址。__initial_sp,这是一个标签，就是栈顶地址，也就是程序启动时栈的初始地址。\n在这段汇编代码中，Reset_Handler就是程序启动时执行的第一个函数，继续往下翻，找到下面这段代码\n; Reset handlerReset_Handler    PROC        EXPORT  Reset_Handler                    [WEAK]        IMPORT  SystemInit        IMPORT  __main                 LDR     R0, =SystemInit                 BLX     R0                 LDR     R0, =__main                 BX      R0                 ENDP\n\n这就是Reset_Handler函数的定义，它导入了别处定义的SystemInit函数和__main函数，首先LDR指令加载SystemInit函数地址到寄存器R0，然后使用BLX指令跳转到R0存储的地址去运行，SystemInit函数用于初始化系统时钟，然后SystemInit函数返回后继续调用__main函数，__main函数用于调用main函数，不用去找__main函数，因为这是编译器自动生成的，它会在main函数之前执行。main函数就是我们的主函数，从这里开始，程序就进入了我们自己的代码中。\n指定从外部Flash启动现在我们知道了程序启动的流程，那么如何指定从外部Flash启动呢？首先，按照文章开头所说，STM32上电默认从内部flash开始执行，因此需要在内部flash中写一个BOOT程序，这个程序的作用主要是，首先初始化QSPI接口，初始化外部Flash，然后将外部flash设置为内存映射模式，紧接着就可以跳转到QSPIFlash内程序的首地址开始运行外部程序，那么这个BOOT程序应该怎么写呢？\n#define W25Qxx_Mem_Addr 0x90000000typedef  void (*pFunction)(void);// 定义一个函数指针，这个指针指向一个无参数无返回值的函数// 定义一个函数指针pFunction JumpToApplication;int main(void)&#123;  //\tSCB_EnableICache();\t\t// 使能ICache\tSCB_EnableDCache();\t\t// 使能DCache\tHAL_Init();\t\t\t\t\t// 初始化HAL库\tSystemClock_Config();\t// 配置系统时钟，主频280MHz\t\t\t\tOSPI_W25Qxx_Init();\t\t// 初始化OSPI和W25Q64\tOSPI_W25Qxx_MemoryMappedMode(); \t // 配置QSPI为内存映射模式\t\tSCB_DisableICache();\t\t// 关闭ICache\tSCB_DisableDCache();\t\t// 关闭Dcache\t\tSysTick-&gt;CTRL = 0;\t\t// 关闭SysTick\tSysTick-&gt;LOAD = 0;\t\t// 清零重载值\tSysTick-&gt;VAL = 0;\t\t\t// 清零计数值\tJumpToApplication = (pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4));\t// 设置起始地址\t__set_MSP(*(__IO uint32_t*) W25Qxx_Mem_Addr);\t// 设置主堆栈指针\tJumpToApplication();\t\t\t// 执行跳转\t\t\twhile (1)\t&#123;\t&#125;&#125;\n\n这是一段简单的代码，首先初始化了HAL库和系统时钟，然后初始化了QSPI和外部Flash，接着将外部Flash设置为内存映射模式，关闭ICache和DCache，最后设置主堆栈指针，并跳转到外部Flash的程序入口地址开始执行。注意，这里需要将外部Flash设置为内存映射模式，这样外部Flash中的程序就可以像访问内部Flash一样访问，不需要再通过QSPI接口访问。\nJumpToApplication = (pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4));\t// 设置起始地址__set_MSP(*(__IO uint32_t*) W25Qxx_Mem_Addr);\t// 设置主堆栈指针JumpToApplication();\t\t\t// 执行跳转\t\n\n这段代码分析如下：\n\n(W25Qxx_Mem_Addr + 4) 指针偏移 即0x90000004\n(__IO uint32_t*) (W25Qxx_Mem_Addr + 4)进行类型转换，将偏移后的地址转换为32位无符号整型指针，加上__IO表明这个变量直接从ram中读取真实值，防止cache\n*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4) 取这个地址上的值，即外部Flash程序入口地址，也即是Reset_Handler的地址\n(pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4))将这个值转换为函数指针，即Reset_Handler函数的指针\nJumpToApplication = (pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4))将这个函数指针赋值给JumpToApplication\n__set_MSP(*(__IO uint32_t*) W25Qxx_Mem_Addr);设置主堆栈指针，即外部Flash程序入口地址\nJumpToApplication();执行跳转，即跳转到外部Flash的程序入口地址开始执行\n\n然后，将这个BOOT程序烧录到内部Flash中，然后上电，程序就会从内部Flash中执行，执行完BOOT程序后，就会跳转到外部Flash的程序入口地址开始执行，这样就实现了从外部Flash启动程序。\n你可能会有疑问，为什么跳转到那个地址就可以执行外部程序，其实外部程序和内部程序都是一样的存储结构，只是存储的位置不同，因而函数的地址也就相应的发生了偏移，内部程序是从0x80000000开始的，而外部程序是从0x90000000开始的，因此，只需要将内部程序的地址加上0x10000000，就可以得到外部程序的入口地址。\nkeil在编译时会生成一个ld文件，即链接文件，这个文件中定义了程序的存储位置，以及各个函数的地址，在编译时，编译器会将这些信息写入到生成的可执行文件中，在程序运行时，这些信息会被加载到内存中，程序就可以根据这些信息找到各个函数的地址，然后执行这些函数。\n编译完成后，还会生成一个map文件，这个文件可以查看程序的存储位置，以及各个函数的地址，这个文件在调试时非常有用，比如查看某个大数组定义的位置，STM32H7有好几个RAM区，而通用DMA并不能访问到所有的RAM区，因此在调试时，需要知道某个大数组定义在哪个RAM区，然后使用相应的DMA通道访问这个数组，否则就会导致DMA访问错误，程序崩溃。以上文件都保存在MDK-ARM/{Project-name}下，你可以在编译完成后查看这些文件，了解程序的存储位置，以及各个函数的地址。\n至于如何修改链接文件，博主再更新文章讲解吧。就这样。\n","categories":["嵌入式","STM32"],"tags":["STM32","STM32H7","外部Flash"]},{"title":"ZYNQ AMP Linux + 裸机","url":"/2024/12/07/ZYNQ-AMP-Linux-%E8%A3%B8%E6%9C%BA/","content":"ZYNQ AMP Linux + 裸机1. 硬件准备\nXilinx ZYNQ7020 SoC开发板 : 笔者这里使用的是微相的ZYNQ7020开发板,当然只要是ZYNQ7020的开发板都可以\n串口线: 用于连接开发板和电脑，登录Linux系统和监视cpu1的输出\nJTAG线:用于调试裸机程序\n\n2. 软件准备\nVivado 2020.2\nVitis 2020.2\npetalinux 2020.2\nubuntu 18.04\n\nvivado 和 vitis的安装在网上一搜一大把这里就不多说了，petalinux的安装博主另开一篇博客再讲\n开发要求如果你使用的是XC7Z010芯片，那么就不用再往下看了，因为XC7Z010只有1个核心，因此是没办法使用AMP的，如果你既想使用Linux，又想使用裸机，可以考虑在PL端使用microblaze,利用软核来实现实时控制。博主这里使用XC7Z020，这个芯片拥有双核A9，因此可以一个核使用Linux，另一个核使用裸机。\n博主目前有一个需求是，使用一个核心来响应外设的中断，完成实时的控制，用另一个核心来运行Linux，主要是在USB端接了一个USB网卡，裸机实现基本没可能，所以只能用Linux，但是Linux又不能实时响应中断，因此就有了这篇博客。\n\n\n3. 实现思路CPU0负责运行Linux系统，CPU1负责运行裸机控制程序。\n3.1 vivado构建工程petalinux需要vivado导出的xsa硬件工程来生成设备树和驱动程序，因此需要首先在vivado中构建硬件工程。\n构建工程可以参考正点原子vitis开发教程，配置好DDR，UART,USB等外设，然后生成bitstream文件，最后导出硬件工程，工程文件即xsa后缀的文件。\n3.2 构建fsblZYNQ启动时，会首先运行一段BOOTROM程序，这是出厂就写死的，BOOTROM程序在完成一些芯片初始化工作之后会启动FSBL程序，FSBL程序会初始化DDR，UART等外设，然后根据启动引脚配置，选择启动方式，包括从JTAG启动，从SD卡启动，从FLASH启动等。本博客选择从SD卡启动，FSBL会从SD卡的BOOT分区读取BOOT.BIN文件，然后读取打包进BOOT.BIN的文件，将这些文件依次写入对应的地址，然后加载并运行uboot程序，uboot程序会加载并运行Linux内核。因此我们需要构建一个FSBL程序，来加载CPU1的程序，并启动CPU1。\n如何启动CPU1请参考ug585 chapter6，这里就不再赘述了，这里主要讲一下如何构建FSBL程序。\nFSBL程序需要使用Vitis来构建，Vitis的安装可以参考正点原子vitis开发教程，构建过程如下：\n\n打开Vitis，根据先前从vivado导出的xsa文件创建平台，创建过程参考正点原子vitis开发教程。\n创建应用工程，模板选择zynq FSBL\n在main.c中添加CPU1启动代码，参考ug585 chapter6\n\n3.3 CPU1运行裸机程序3.4 CPU0运行Linux在使用amp之前请一定首先要自己尝试配置好一个可以在芯片上正常运行的Linux系统，因为amp的配置和Linux的配置是差不多的，以下就默认你知道如何配置一个可以正常运行的Linux系统。\nCPU0使用的linux系统通过petalinux来制作，将vivado导出的xsa后缀工程文件拷贝到Ubuntu系统下，构建过程参考ug1144，petalinux命令查询可以参考ug1157.\npetalinux-create -t project --template zynq -n linux_amppetalinux-config --get-hw-description linux_amp.xsa\n\n-n 指定工程名，–template zynq指定使用zynq模板，–get-hw-description 指定硬件工程文件。\n运行petalinux-config 进入配置界面进入DTG Settings -&gt; kernel Bootargs -&gt; 取消选中generate boot args automatically,然后手动添加console=ttyPS0,115200 maxcpus=1 clk_ignore_unused root=/dev/mmcblk0p2 rw earlyprintk rootwait，然后保存退出。maxcpus&#x3D;1表示只使用一个核心,防止linux同时使用两个核心，抢占CPU1裸机程序的核心clk_ignore_unused表示忽略未使用的时钟，Linux的电源管理策略会默认关闭未使用的时钟，导致CPU1使用的部分外设时钟被关闭，无法运行，root&#x3D;&#x2F;dev&#x2F;mmcblk0p2表示根文件系统在mmcblk0p2分区，rw表示可读可写，earlyprintk表示在内核启动时打印信息，rootwait表示等待根文件系统挂载。\n配置完成后，运行以下命令生成Linux系统\npetalinux-build\n等待构建完成\n3.2 CPU1运行裸机程序","categories":["嵌入式","ZYNQ"],"tags":["ZYNQ","AMP","Linux","裸机"]},{"title":"使用ZYNQ解码高速ADCLVDS输出(2)","url":"/2024/09/26/%E4%BD%BF%E7%94%A8ZYNQ%E8%A7%A3%E7%A0%81%E9%AB%98%E9%80%9FADCLVDS%E8%BE%93%E5%87%BA-2/","content":"","categories":["嵌入式","FPGA"]},{"title":"电子设计常用芯片集锦","url":"/2023/10/18/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87%E9%9B%86%E9%94%A6/","content":"电子设计常用芯片Part 1 串口通信\nCH340C\n\n国产芯片\n外围器件少\n双列SOP16封装\n焊接难度小\n占板面积大\n便宜\n\n\nCP2102 \n\n国外芯片\nQFN封装\n外围器件少\n占板面积小\n焊接难度大\n贵\n\n\n\n\nPart 2 DC-DC 降压\nSY8088AAC特性：\n2.5 ~ 5.5V输入电压\n40uA静态电流\n最高1A电流输出\nEN使能上升阈值最低电压1.5V\nSOT23-5封装\n\n\n\n\n\nSY8089AAC特性：\n2.7 ~ 5.5V输入电压\n最高2A持续电流输出\nEN使能上升阈值最低电压1.5V\nSOT23-5封装\n\n\n\n\n\nMT3520B特性：\n最高96%效率\n最高2A持续电流\n40uA静态电流\n最低输出0.6V\n2.3 ~ 6V输入电压\nSOT23-5封装\nEN使能阈值1.5V\nEN失能阈值0.3V\n\n\n\n\n\nTLV62569特性：\n2.5 ~ 5.5V输入电压\n35uA静态电流\n最高2A输出电流\nEN使能典型阈值0.95V\n软起动时间800us\n\n\n\nPart 3 LDO 降压\nRT9012\n\n双通道输出\n带使能端\n300mA输出能力\n\n\nRT9013\n\n单通道输出能力\n500mA输出能力\n\n\n\n","categories":["硬件","芯片"]},{"title":"使用hexo + NexT搭建网站","url":"/2025/11/04/%E4%BD%BF%E7%94%A8hexo-NexT%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/","content":"使用hexo + NexT搭建网站\n待补充\n\n\n添加额外功能添加阅读时长在blog根目录下打开git bash，执行如下命令：\nnpm install hexo-word-counter\n\n\n\n在hexo配置文件中添加如下配置：\n# _config.ymlsymbols_count_time:  symbols: true  time: true  total_symbols: true  total_time: true  exclude_codeblock: false  awl: 4  wpm: 275  suffix: &quot;mins.&quot;\n\n在主题配置文件中添加如下配置：\n# themes\\next\\_config.yml# Post meta display settingspost_meta:  item_text: true# Post wordcount display settings# Dependencies: https://github.com/next-theme/hexo-word-countersymbols_count_time:  separated_meta: true  item_text_total: false\n参数说明：\n\nitem_text：本文字数和阅读时长，是否使用文本展示。若为 false 则仅展示图标。\nseparated_meta：是否换行显示本文字数及阅读时长。\nitem_text_total：站点总字数和站点阅读时长，是否使用文本展示。若为 false 则仅展示图标。\n\n","categories":["网站建设","Hexo","NexT"],"tags":["hexo"]},{"title":"使用ZYNQ解码高速ADCLVDS输出","url":"/2024/09/13/%E4%BD%BF%E7%94%A8ZYNQ%E8%A7%A3%E7%A0%81%E9%AB%98%E9%80%9FADCLVDS%E8%BE%93%E5%87%BA/","content":"使用ZYNQ解码高速ADCLVDS输出1. LVDS简介LVDS（Low Voltage Differential Signaling）是一种差分信号传输技术，广泛应用于高速数据传输中。如图所示，\n\nLVDS信号通过两个差分对进行传输，每个差分对由一个正信号和一个负信号组成。这种信号传输方式具有低功耗、低噪声和高速传输的特点，因此在高速数据传输中得到了广泛应用。\n2.AFE5832简介AFE5832是一款高性能的模拟前端（AFE）芯片，用于高速ADC（模数转换器）的输出。它支持LVDS接口，可以将模拟信号转换为数字信号，并输出到外部设备。AFE5832具有以下特点：\n\n高分辨率：支持10位或12位分辨率，可以满足不同应用场景的需求。\n高采样率：支持最高100 MSPS的采样率，适用于高速数据采集。\n低功耗：采用低功耗设计，可以在低电压下稳定工作。\n支持LVDS接口：支持LVDS接口，可以将模拟信号转换为数字信号，并输出到外部设备。\n\n\n\n\nAFE5832的LVDS输出AFE5832的LVDS输出接口由十八个差分对组成，分别为1对bit时钟，1对帧时钟，16对数据，每个差分对由一个正信号和一个负信号组成。这些差分对可以同时传输多个通道的数据，从而实现高速数据传输。如图所示，为10bit分辨率下LVDS输出的示意图。\n\n可以看出，数据输出是DDR的，即数据在时钟的上升沿和下降沿都发生变化，数据时钟变化边沿在数据稳定的范围内，但是帧时钟与数据输出对齐的。这样可以降低数据时钟的频率，但是这样也增加了解码的难度。\n3. ZYNQ解码AFE5832的LVDS输出3.1 ZYNQ的LVDS接口参考ZYNQ的ug471第91页–96页，ZYNQ内部有HP(high performance) bank和HR(high range) bank，HR bank仅支持LVDS_25标准，HP bank仅支持LVDS标准。\n博主这里使用的XC7Z020芯片，这片芯片仅有HR bank，因此这里使用HR bank 的LVDS_25接口，这里按照手册所说，使用IO的所在bank的VCCO电平需要为2.5V，但是博主前期设计的时候并没有注意到这里，AFE5832和7020均使用1.8V标准，但是实测在引脚约束里将引脚类型设置为LVDS_25后，数据可以正常传输，因此这里暂时没有发现什么问题。\n查阅ds187手册第12页以及AFE5832的LVDS接口电平，发现实际上是可以兼容的，但最好还是按照手册要求来设计电路。\n3.2 怎么解码首先，以下所有操作都是使用verilog语言在FPGA中编程实现，如果你用MCU，请转到FPGA，因为数据时钟频率至少在100M以上，MCU的核心和引脚很难处理这么高的频率数据\n参考这里的输出时序图，我们知道在数据时钟的上升沿和下降沿都存在数据，你可能首先能想到的是使用两个always语句，一个在上升沿，一个在下降沿，触发时钟选择DCLK，使用两个计数器来计数上升沿和下降沿，然后将数据做拼接和对齐，但是这样实现起来非常复杂，数据频率太高，并且非常占用布线资源，也会使得部分时钟线扇出过大导致无法综合。\nIDDR原语IDDR原语是Xilinx提供的一个用于双沿触发的寄存器，它可以在时钟上升沿触发时将数据存储到一个寄存器中，然后在时钟下降沿触发时将数据从寄存器中读取出来。\n参考ug471第109页，IDDR有三种工作模式，分别为\n\nOPPPSITE_EDGE mode\nSAME_EDGE mode\nSAME_EDGE_PIPELENED mode\n\n具体模式的输出时序可以参考手册来看，这不是这篇文章的重点，因此知道即可。\n3.3 ISERDESE2 原语ug471手册中对ISERDESE2的介绍如下：\n\nThe ISERDESE2 in 7 series FPGAs is a dedicated serial-to-parallel converter with specific clocking and logic features designed to facilitate the implementation of high-speed source-synchronous applications. The ISERDESE2 avoids the additional timing complexities encountered when designing deserializers in the FPGA fabric.\n\n\nISERDESE2在7系列FPGAs中是一个专用的串行到并行转换器，具有特定的时钟和逻辑特性，旨在促进高速源同步应用程序的实现。ISERDESE2避免了在FPGA结构中设计反序列化器时遇到的额外定时复杂性。\n\nISERDESE2是Xilinx提供的一个用于串并转换的原语，支持高速数据传输，而不需要特殊FPGA布线来满足数据频率要求，总结来收就是ZYNQ的PL资源中一个特殊的模块，是专门用于高速数据解串的。在代码中例化它之后你可以在综合布线完成之后的芯片资源使用情况中看到它。\n它可以将串行数据转换为并行数据，支持SDR和DDR输入，ISERDESE2可以配置为2、3、4、5、6、7、8、10，14的数据宽度。其中10和14位数据宽度需要使用两个ISERDESE2原语并联实现。\n同时，允许用户动态调整移位，即如果解码结果出现错位，可以动态调整移位，从而实现数据对齐。这个功能由bitslip子模块实现。\nISERDESE2模块的输入输出如下图所示：\n篇幅有限，具体引脚功能请参考ug471手册。\n3.4 代码实现待更新\n 回到顶部\n","categories":["嵌入式","FPGA"],"tags":["zynq","adc"]}]