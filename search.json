[{"title":"EA3036C","url":"/2025/11/04/EA3036C/","content":"EA3036C\n简介\nEA3036C是一款集成了3通道的电源管理IC，可以用于由单个Li-ion电池或5V DC 适配器供电的设备。这款芯片集成了3个同步Buck转换器，可以在轻负载和高负载情况下提供高效率的电源输出。\n\n","categories":["硬件","电源","PMIC"],"tags":["PMIC","电源设计","EA3036C"]},{"title":"Altium Designer 技巧指南","url":"/2025/11/05/Altium-Designer-%E6%8A%80%E5%B7%A7%E6%8C%87%E5%8D%97/","content":"🚧\nAltium Designer 技巧指南 🚧\n多层级原理图快速确定网络连接关系\nTools -&gt; Preferences -&gt; System -&gt; Design Insight\n该栏目下包含四个可供勾选的项目，博主这里全部勾选了。\n同时在Connectivity Insight Options下，可以选择层级关系显示的触发方式：\n\n\nMouse Hover：即鼠标放置在指定网络上，其中触发延迟可以由本页中的Mouse Hover Delay滑动条选择。\n\n\nAlt + Double Click：即按住Alt键的同时鼠标双击指定网络这里可以根据需求自由选择，当然博主这里也是全部选上了。\n\n\n1. 快捷键\n1.1 栅格与尺寸相关\n1.1.1 尺寸\nAltium Designer 包括两种尺寸，mil和mm，其换算关系为$$1mil = 0.0254mm$$\n所以，在绘制原理图时，由于不同元件的尺寸不同，需要在工作中切换不同的吸附栅格来保证元件快速对齐与设计美观。\n\n\n\n快捷键\n功能\n\n\n\n\nV + U\n切换单位\n\n\n\n也可以在原理图或PCB的Properties下的General分类下点击Units的mm或者mil进行切换。\n\n1.1.2 栅格 Grid\nAltium Designer 包括三种栅格:\n\n\n可视栅格\n工作区上看到的网格，作用类似于坐标线，帮助用户掌握元件间的距离。\n\n\n\n\n\n快捷键\n功能\n\n\n\n\nCtrl + Shift + G\n切换可视栅格尺寸\n\n\n\n\n\n吸附/捕捉栅格\n控制光标每次移动的距离，可以理解为鼠标拖动元件时，元件最小移动间距。\n\n\n\n\n\n快捷键\n功能\n\n\n\n\nG\n正向按顺序切换捕获栅格尺寸\n\n\nShift + G\n反向按顺序切换捕获栅格尺寸\n\n\n\n\n\n电气栅格\n电气栅格的作用是在移动或放置元件时，当元件与周围电气实体的距离在电气栅格的设置范围内时，元件与电气实体会互相吸住。\n\n\n\n\n\n快捷键\n功能\n\n\n\n\nShift + E\n切换电气栅格\n\n\n\n注意：\nAltium Designer 预设了几组栅格尺寸，Tools -&gt; Preferences -&gt; Schematic -&gt; Design Grids在这里可以按需设定。\n\n\n","categories":["开发工具","EDA","Altium Designer"],"tags":["Altium Designer","技巧"]},{"title":"STM32H7指定从外部Flash启动程序","url":"/2024/09/27/STM32H7%E6%8C%87%E5%AE%9A%E4%BB%8E%E5%A4%96%E9%83%A8Flash%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/","content":"STM32H7指定从外部Flash启动程序\n代码启动流程\n单片机默认上电之后会从0x80000000处开始执行代码，也就是从内部flash启动。首先我们来看启动流程。\n在开始之前，首先得确保你可以找得到.s文件，比如startup_stm32h7b0xx.s，这个文件是启动文件，在STM32CubeMX生成的代码中，这个文件位于MDK_ARM目录下。\n然后，找到如下代码：\n__Vectors       DCD     __initial_sp                      ; Top of Stack                DCD     Reset_Handler                     ; Reset Handler                DCD     NMI_Handler                       ; NMI Handler                DCD     HardFault_Handler                 ; Hard Fault Handler                DCD     MemManage_Handler                 ; MPU Fault Handler                DCD     BusFault_Handler                  ; Bus Fault Handler                DCD     UsageFault_Handler                ; Usage Fault Handler                DCD     0                                 ; Reserved                DCD     0                                 ; Reserved                DCD     0                                 ; Reserved                DCD     0                                 ; Reserved                DCD     SVC_Handler                       ; SVCall Handler                DCD     DebugMon_Handler                  ; Debug Monitor Handler                DCD     0                                 ; Reserved                DCD     PendSV_Handler                    ; PendSV Handler                DCD     SysTick_Handler                   ; SysTick Handler\n\n__Vectors就是启动文件中定义的向量表，也就是中断向量表，在程序启动时，会根据这个向量表来跳转到相应的函数。\nDCD指令定义一个32位的常量，这里定义了中断向量表中的各个中断处理函数的入口地址。\n__initial_sp,这是一个标签，就是栈顶地址，也就是程序启动时栈的初始地址。\n在这段汇编代码中，Reset_Handler就是程序启动时执行的第一个函数，继续往下翻，找到下面这段代码\n; Reset handlerReset_Handler    PROC        EXPORT  Reset_Handler                    [WEAK]        IMPORT  SystemInit        IMPORT  __main                 LDR     R0, =SystemInit                 BLX     R0                 LDR     R0, =__main                 BX      R0                 ENDP\n这就是Reset_Handler函数的定义，它导入了别处定义的SystemInit函数和__main函数，首先LDR指令加载SystemInit函数地址到寄存器R0，然后使用BLX指令跳转到R0存储的地址去运行，SystemInit函数用于初始化系统时钟，然后SystemInit函数返回后继续调用__main函数，__main函数用于调用main函数，不用去找__main函数，因为这是编译器自动生成的，它会在main函数之前执行。main函数就是我们的主函数，从这里开始，程序就进入了我们自己的代码中。\n指定从外部Flash启动\n现在我们知道了程序启动的流程，那么如何指定从外部Flash启动呢？首先，按照文章开头所说，STM32上电默认从内部flash开始执行，因此需要在内部flash中写一个BOOT程序，这个程序的作用主要是，首先初始化QSPI接口，初始化外部Flash，然后将外部flash设置为内存映射模式，紧接着就可以跳转到QSPIFlash内程序的首地址开始运行外部程序，那么这个BOOT程序应该怎么写呢？\n#define W25Qxx_Mem_Addr 0x90000000typedef  void (*pFunction)(void);// 定义一个函数指针，这个指针指向一个无参数无返回值的函数// 定义一个函数指针pFunction JumpToApplication;int main(void)&#123;  //\tSCB_EnableICache();\t\t// 使能ICache\tSCB_EnableDCache();\t\t// 使能DCache\tHAL_Init();\t\t\t\t\t// 初始化HAL库\tSystemClock_Config();\t// 配置系统时钟，主频280MHz\t\t\t\tOSPI_W25Qxx_Init();\t\t// 初始化OSPI和W25Q64\tOSPI_W25Qxx_MemoryMappedMode(); \t // 配置QSPI为内存映射模式\t\tSCB_DisableICache();\t\t// 关闭ICache\tSCB_DisableDCache();\t\t// 关闭Dcache\t\tSysTick-&gt;CTRL = 0;\t\t// 关闭SysTick\tSysTick-&gt;LOAD = 0;\t\t// 清零重载值\tSysTick-&gt;VAL = 0;\t\t\t// 清零计数值\tJumpToApplication = (pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4));\t// 设置起始地址\t__set_MSP(*(__IO uint32_t*) W25Qxx_Mem_Addr);\t// 设置主堆栈指针\tJumpToApplication();\t\t\t// 执行跳转\t\t\twhile (1)\t&#123;\t&#125;&#125;\n这是一段简单的代码，首先初始化了HAL库和系统时钟，然后初始化了QSPI和外部Flash，接着将外部Flash设置为内存映射模式，关闭ICache和DCache，最后设置主堆栈指针，并跳转到外部Flash的程序入口地址开始执行。注意，这里需要将外部Flash设置为内存映射模式，这样外部Flash中的程序就可以像访问内部Flash一样访问，不需要再通过QSPI接口访问。\nJumpToApplication = (pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4));\t// 设置起始地址__set_MSP(*(__IO uint32_t*) W25Qxx_Mem_Addr);\t// 设置主堆栈指针JumpToApplication();\t\t\t// 执行跳转\t\n这段代码分析如下：\n\n\n(W25Qxx_Mem_Addr + 4) 指针偏移 即0x90000004\n\n\n(__IO uint32_t*) (W25Qxx_Mem_Addr + 4)进行类型转换，将偏移后的地址转换为32位无符号整型指针，加上__IO表明这个变量直接从ram中读取真实值，防止cache\n\n\n*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4) 取这个地址上的值，即外部Flash程序入口地址，也即是Reset_Handler的地址\n\n\n(pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4))将这个值转换为函数指针，即Reset_Handler函数的指针\n\n\nJumpToApplication = (pFunction) (*(__IO uint32_t*) (W25Qxx_Mem_Addr + 4))将这个函数指针赋值给JumpToApplication\n\n\n__set_MSP(*(__IO uint32_t*) W25Qxx_Mem_Addr);设置主堆栈指针，即外部Flash程序入口地址\n\n\nJumpToApplication();执行跳转，即跳转到外部Flash的程序入口地址开始执行\n\n\n然后，将这个BOOT程序烧录到内部Flash中，然后上电，程序就会从内部Flash中执行，执行完BOOT程序后，就会跳转到外部Flash的程序入口地址开始执行，这样就实现了从外部Flash启动程序。\n你可能会有疑问，为什么跳转到那个地址就可以执行外部程序，其实外部程序和内部程序都是一样的存储结构，只是存储的位置不同，因而函数的地址也就相应的发生了偏移，内部程序是从0x80000000开始的，而外部程序是从0x90000000开始的，因此，只需要将内部程序的地址加上0x10000000，就可以得到外部程序的入口地址。\nkeil在编译时会生成一个ld文件，即链接文件，这个文件中定义了程序的存储位置，以及各个函数的地址，在编译时，编译器会将这些信息写入到生成的可执行文件中，在程序运行时，这些信息会被加载到内存中，程序就可以根据这些信息找到各个函数的地址，然后执行这些函数。\n编译完成后，还会生成一个map文件，这个文件可以查看程序的存储位置，以及各个函数的地址，这个文件在调试时非常有用，比如查看某个大数组定义的位置，STM32H7有好几个RAM区，而通用DMA并不能访问到所有的RAM区，因此在调试时，需要知道某个大数组定义在哪个RAM区，然后使用相应的DMA通道访问这个数组，否则就会导致DMA访问错误，程序崩溃。以上文件都保存在MDK-ARM/{Project-name}下，你可以在编译完成后查看这些文件，了解程序的存储位置，以及各个函数的地址。\n至于如何修改链接文件，博主再更新文章讲解吧。就这样。\n","categories":["嵌入式","STM32"],"tags":["STM32","STM32H7","外部Flash"]},{"title":"ZYNQ AMP Linux + 裸机","url":"/2024/12/07/ZYNQ-AMP-Linux-%E8%A3%B8%E6%9C%BA/","content":"ZYNQ AMP Linux + 裸机\n1. 硬件准备\n\n\nXilinx ZYNQ7020 SoC开发板 : 笔者这里使用的是微相的ZYNQ7020开发板,当然只要是ZYNQ7020的开发板都可以\n\n\n串口线: 用于连接开发板和电脑，登录Linux系统和监视cpu1的输出\n\n\nJTAG线:用于调试裸机程序\n\n\n2. 软件准备\n\n\nVivado 2020.2\n\n\nVitis 2020.2\n\n\npetalinux 2020.2\n\n\nubuntu 18.04\n\n\nvivado 和 vitis的安装在网上一搜一大把这里就不多说了，petalinux的安装博主另开一篇博客再讲\n开发要求\n如果你使用的是XC7Z010芯片，那么就不用再往下看了，因为XC7Z010只有1个核心，因此是没办法使用AMP的，如果你既想使用Linux，又想使用裸机，可以考虑在PL端使用microblaze,利用软核来实现实时控制。博主这里使用XC7Z020，这个芯片拥有双核A9，因此可以一个核使用Linux，另一个核使用裸机。\n博主目前有一个需求是，使用一个核心来响应外设的中断，完成实时的控制，用另一个核心来运行Linux，主要是在USB端接了一个USB网卡，裸机实现基本没可能，所以只能用Linux，但是Linux又不能实时响应中断，因此就有了这篇博客。\n\n3. 实现思路\nCPU0负责运行Linux系统，CPU1负责运行裸机控制程序。\n3.1 vivado构建工程\npetalinux需要vivado导出的xsa硬件工程来生成设备树和驱动程序，因此需要首先在vivado中构建硬件工程。\n构建工程可以参考正点原子vitis开发教程，配置好DDR，UART,USB等外设，然后生成bitstream文件，最后导出硬件工程，工程文件即xsa后缀的文件。\n3.2 构建fsbl\nZYNQ启动时，会首先运行一段BOOTROM程序，这是出厂就写死的，BOOTROM程序在完成一些芯片初始化工作之后会启动FSBL程序，FSBL程序会初始化DDR，UART等外设，然后根据启动引脚配置，选择启动方式，包括从JTAG启动，从SD卡启动，从FLASH启动等。本博客选择从SD卡启动，FSBL会从SD卡的BOOT分区读取BOOT.BIN文件，然后读取打包进BOOT.BIN的文件，将这些文件依次写入对应的地址，然后加载并运行uboot程序，uboot程序会加载并运行Linux内核。因此我们需要构建一个FSBL程序，来加载CPU1的程序，并启动CPU1。\n如何启动CPU1请参考ug585 chapter6，这里就不再赘述了，这里主要讲一下如何构建FSBL程序。\nFSBL程序需要使用Vitis来构建，Vitis的安装可以参考正点原子vitis开发教程，构建过程如下：\n\n\n打开Vitis，根据先前从vivado导出的xsa文件创建平台，创建过程参考正点原子vitis开发教程。\n\n\n创建应用工程，模板选择zynq FSBL\n\n\n在main.c中添加CPU1启动代码，参考ug585 chapter6\n\n\n3.3 CPU1运行裸机程序\n3.4 CPU0运行Linux\n在使用amp之前请一定首先要自己尝试配置好一个可以在芯片上正常运行的Linux系统，因为amp的配置和Linux的配置是差不多的，以下就默认你知道如何配置一个可以正常运行的Linux系统。\nCPU0使用的linux系统通过petalinux来制作，将vivado导出的xsa后缀工程文件拷贝到Ubuntu系统下，构建过程参考ug1144，petalinux命令查询可以参考ug1157.\npetalinux-create -t project --template zynq -n linux_amppetalinux-config --get-hw-description linux_amp.xsa\n-n 指定工程名，–template zynq指定使用zynq模板，–get-hw-description 指定硬件工程文件。\n运行petalinux-config 进入配置界面进入DTG Settings -&gt; kernel Bootargs -&gt; 取消选中generate boot args automatically,然后手动添加console=ttyPS0,115200 maxcpus=1 clk_ignore_unused root=/dev/mmcblk0p2 rw earlyprintk rootwait，然后保存退出。\nmaxcpus=1表示只使用一个核心,防止linux同时使用两个核心，抢占CPU1裸机程序的核心\nclk_ignore_unused表示忽略未使用的时钟，Linux的电源管理策略会默认关闭未使用的时钟，导致CPU1使用的部分外设时钟被关闭，无法运行，\nroot=/dev/mmcblk0p2表示根文件系统在mmcblk0p2分区，\nrw表示可读可写，\nearlyprintk表示在内核启动时打印信息，\nrootwait表示等待根文件系统挂载。\n配置完成后，运行以下命令生成Linux系统\npetalinux-build\n等待构建完成\n3.2 CPU1运行裸机程序\n","categories":["嵌入式","ZYNQ"],"tags":["ZYNQ","AMP","Linux","裸机"]},{"title":"ZYNQ项目开发指南","url":"/2025/11/05/ZYNQ%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","content":"ZYNQ 项目开发指南\n写在前面\n本博客为博主在项目开发过程中，积累的一些开发经验，以博客的形式记录下来，一是方便自己日后随时查阅，二是分享出来帮助同样遇到问题的同学，少走弯路。共勉！\n如果遇到有问题但是博主没有记录下来的，欢迎关注未定义科研摸鱼手册微信公众号，后台私信我~\n\nVivado\n🚧\n复制block design\n场景：博主想要直接复制vivado工程到另外一个文件夹进行其他更改时，会发现在复制工程上修改的部分也出现在原工程，因此直接复制的方法不可行。\n解决方式：\n\n\n在原工程TCL控制台使用如下命令：\n\n\nwrite_bd_tcl &lt;path/to/new/tclfile&gt;\n根据你的需求修改&lt;path/to/new/tclfile&gt;为你的目标地址。\n\n\n然后建立一个新工程，然后在新工程的TCL控制台执行如下命令：\n\n\nsource &lt;path/to/new/tclfile&gt;\n替换&lt;path/to/new/tclfile&gt;为第一步生成的tcl文件。\n即可在新工程创建一个全新的与原block design 相同的设计。\n在ip核工程内进行仿真时出现ERROR:[XSIM 43-3268] ERROR :[XSIM 43-3217]\n场景:vivado工程内编辑ip核，在ip核临时工程中进行仿真时会出现这个错误。\n解决方法：临时工程内在TCL控制台运行命令：\nset_property library xil_defaultlib [get_files]\n猜测是临时ip核工程，只需要进行一些ip核源代码修改工作，没有添加一些基本库。\nVitis\n🚧\nPetaLinux\nPetaLinux 安装   🚧\n从SD卡启动PetaLinux\n\n\n找到一张不小于8G的SD卡或者TF卡\n\n\n使用读卡器或者其他工具，连接到电脑，使用任意分区工具，将SD卡进行分区\n\n\n\n\n\n分区名称\n分区大小\n分区类型\n用途\n\n\n\n\nboot\n512MB\nFAT32\n存储启动文件、镜像等\n\n\nrootfs\nSD卡剩余空间\nEXT4\n挂载文件系统\n\n\n\n\n\n将PetaLinux编译得到的BOOT.bin,image.ub,boot.scr文件拷贝到boot分区\n\n\ncd ./images/linux   #切换到编译输出文件夹sudo cp BOOT.bin image.ub boot.scr /media/&lt;user&gt;/boot  # 拷贝文件\n其中/media/&lt;user&gt;/boot为ubuntu 默认挂载SD卡的位置，&lt;user&gt;为你的ubuntu账户名，根据你的情况修改\n\n\n将PetaLinux编译得到的rootfs.tar.gz解压到rootfs分区\n\n\n# 在上一步的基础上sudo cp rootfs.tar.gz /media/&lt;user&gt;/rootfs    #拷贝根文件系统到rootfs分区 sudo tar -zxvf rootfs.tar.gz      #解压sudo sync # 同步一下\n\n\n将SD卡插到开发板的SD卡槽上\n\n\n切换启动跳线到SD卡\n\n\n接上串口线，接上电源，启动\n\n\n\n不切换启动跳线的情况下从SD卡启动的方法\n\n\n前置工作准备完成\n\n\n打开vitis,File -&gt; new -&gt; Application Projects\n\n\n前置配置都参考正常创建vitis工程即可\n\n\n选择模板’Template’时,选择Zynq FSBL,然后Finish\n\n\n这一步创建了一个ZYNQ的FSBL即First Stage BootLoader（第一阶段启动加载器），\n这个程序会在上电时首先读取启动配置寄存器，简单来说就是启动配置引脚电平，然后识别启动模式，根据对应的启动模式完成后续配置和加载，最后启动正常程序。\n因此可以直接指定启动模式，这样就省去了开发阶段频繁的切换启动跳线。\n\n\n打开FSBL工程的main.c文件，找到第357行，或者如下代码，然后按照注释添加一行代码。\n\n\n/** Read bootmode register*/BootModeRegister = Xil_In32(BOOT_MODE_REG);BootModeRegister &amp;= BOOT_MODES_MASK;// 添加这一行BootModeRegister = SD_MODE;\n添加这行代码直接指定了BootModeRegister这一变量的值，阅读后面的代码即可知道，这个变量控制了程序启动的方式。\n编译，下载，然后就可以发现系统从SD卡正常启动了。\n根据Xilinx官方手册说明，SD卡启动仅支持SD0\n如果你的开发板SD卡使用了SD0，那么到这里可以结束了\n但是，如果由于其他设计原因，使用了SD1作为启动SD卡，那么可以继续看下去\n\n\n添加SD1作为启动SD卡\n\n\n还是在main.c文件中找到如下代码(513行左右)：\n/*    * Check for valid flash address*/if ((FlashReadBaseAddress != XPS_QSPI_LINEAR_BASEADDR) &amp;&amp;        (FlashReadBaseAddress != XPS_NAND_BASEADDR) &amp;&amp;        (FlashReadBaseAddress != XPS_NOR_BASEADDR) &amp;&amp;        (FlashReadBaseAddress != XPS_SDIO0_BASEADDR) &amp;&amp;        (FlashReadBaseAddress != 0xE0101000)) &#123;    fsbl_printf(DEBUG_GENERAL,&quot;INVALID_FLASH_ADDRESS \\r\\n&quot;);    OutputStatus(INVALID_FLASH_ADDRESS);    FsblFallback();&#125;\n这段代码检查启动Flash的启动地址，即外设控制器的地址，如果不存在那么启动失败，正常情况下SD1的地址是不在里面的，我们这里直接添加上\nif 判断中添加一项(FlashReadBaseAddress != 0xE0101000)，将SD1也包含进去。\n编译，下载，结束。\nlinux启动自动加载ko模块/运行脚本\n","categories":["ZYNQ","FPGA"],"tags":["ZYNQ"]},{"title":"使用hexo + NexT搭建网站","url":"/2025/11/04/%E4%BD%BF%E7%94%A8hexo-NexT%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/","content":"使用hexo + NexT搭建网站\n\n待补充\n\n\n添加额外功能\n添加阅读时长\n在blog根目录下打开git bash，执行如下命令：\nnpm install hexo-word-counter\n\n在hexo配置文件中添加如下配置：\n# _config.ymlsymbols_count_time:  symbols: true  time: true  total_symbols: true  total_time: true  exclude_codeblock: false  awl: 4  wpm: 275  suffix: &quot;mins.&quot;\n在主题配置文件中添加如下配置：\n# themes\\next\\_config.yml# Post meta display settingspost_meta:  item_text: true# Post wordcount display settings# Dependencies: https://github.com/next-theme/hexo-word-countersymbols_count_time:  separated_meta: true  item_text_total: false\n参数说明：\n\n\nitem_text：本文字数和阅读时长，是否使用文本展示。若为 false 则仅展示图标。\n\n\nseparated_meta：是否换行显示本文字数及阅读时长。\n\n\nitem_text_total：站点总字数和站点阅读时长，是否使用文本展示。若为 false 则仅展示图标。\n\n\n","categories":["网站建设","Hexo","NexT"],"tags":["hexo"]},{"title":"使用ZYNQ解码高速ADCLVDS输出(2) 🚧","url":"/2024/09/26/%E4%BD%BF%E7%94%A8ZYNQ%E8%A7%A3%E7%A0%81%E9%AB%98%E9%80%9FADCLVDS%E8%BE%93%E5%87%BA-2/","content":"","categories":["嵌入式","FPGA"]},{"title":"使用ZYNQ解码高速ADCLVDS输出","url":"/2024/09/13/%E4%BD%BF%E7%94%A8ZYNQ%E8%A7%A3%E7%A0%81%E9%AB%98%E9%80%9FADCLVDS%E8%BE%93%E5%87%BA/","content":"使用ZYNQ解码高速ADCLVDS输出\n1. LVDS简介\nLVDS（Low Voltage Differential Signaling）是一种差分信号传输技术，广泛应用于高速数据传输中。如图所示，\n\nLVDS信号通过两个差分对进行传输，每个差分对由一个正信号和一个负信号组成。这种信号传输方式具有低功耗、低噪声和高速传输的特点，因此在高速数据传输中得到了广泛应用。\n2.AFE5832简介\nAFE5832是一款高性能的模拟前端（AFE）芯片，用于高速ADC（模数转换器）的输出。它支持LVDS接口，可以将模拟信号转换为数字信号，并输出到外部设备。AFE5832具有以下特点：\n\n\n高分辨率：支持10位或12位分辨率，可以满足不同应用场景的需求。\n\n\n高采样率：支持最高100 MSPS的采样率，适用于高速数据采集。\n\n\n低功耗：采用低功耗设计，可以在低电压下稳定工作。\n\n\n支持LVDS接口：支持LVDS接口，可以将模拟信号转换为数字信号，并输出到外部设备。\n\n\n\nAFE5832的LVDS输出\nAFE5832的LVDS输出接口由十八个差分对组成，分别为1对bit时钟，1对帧时钟，16对数据，每个差分对由一个正信号和一个负信号组成。这些差分对可以同时传输多个通道的数据，从而实现高速数据传输。如图所示，为10bit分辨率下LVDS输出的示意图。\n\n可以看出，数据输出是DDR的，即数据在时钟的上升沿和下降沿都发生变化，数据时钟变化边沿在数据稳定的范围内，但是帧时钟与数据输出对齐的。这样可以降低数据时钟的频率，但是这样也增加了解码的难度。\n3. ZYNQ解码AFE5832的LVDS输出\n3.1 ZYNQ的LVDS接口\n参考ZYNQ的ug471第91页–96页，ZYNQ内部有HP(high performance) bank和HR(high range) bank，HR bank仅支持LVDS_25标准，HP bank仅支持LVDS标准。\n博主这里使用的XC7Z020芯片，这片芯片仅有HR bank，因此这里使用HR bank 的LVDS_25接口，这里按照手册所说，使用IO的所在bank的VCCO电平需要为2.5V，但是博主前期设计的时候并没有注意到这里，AFE5832和7020均使用1.8V标准，但是实测在引脚约束里将引脚类型设置为LVDS_25后，数据可以正常传输，因此这里暂时没有发现什么问题。\n查阅ds187手册第12页以及AFE5832的LVDS接口电平，发现实际上是可以兼容的，但最好还是按照手册要求来设计电路。\n3.2 怎么解码\n首先，以下所有操作都是使用verilog语言在FPGA中编程实现，如果你用MCU，请转到FPGA，因为数据时钟频率至少在100M以上，MCU的核心和引脚很难处理这么高的频率数据\n参考这里的输出时序图，我们知道在数据时钟的上升沿和下降沿都存在数据，你可能首先能想到的是使用两个always语句，一个在上升沿，一个在下降沿，触发时钟选择DCLK，使用两个计数器来计数上升沿和下降沿，然后将数据做拼接和对齐，但是这样实现起来非常复杂，数据频率太高，并且非常占用布线资源，也会使得部分时钟线扇出过大导致无法综合。\nIDDR原语\nIDDR原语是Xilinx提供的一个用于双沿触发的寄存器，它可以在时钟上升沿触发时将数据存储到一个寄存器中，然后在时钟下降沿触发时将数据从寄存器中读取出来。\n参考ug471第109页，IDDR有三种工作模式，分别为\n\n\nOPPPSITE_EDGE mode\n\n\nSAME_EDGE mode\n\n\nSAME_EDGE_PIPELENED mode\n\n\n具体模式的输出时序可以参考手册来看，这不是这篇文章的重点，因此知道即可。\n3.3 ISERDESE2 原语\nug471手册中对ISERDESE2的介绍如下：\n\nThe ISERDESE2 in 7 series FPGAs is a dedicated serial-to-parallel converter with specific clocking and logic features designed to facilitate the implementation of high-speed source-synchronous applications. The ISERDESE2 avoids the additional timing complexities encountered when designing deserializers in the FPGA fabric.\n\n\nISERDESE2在7系列FPGAs中是一个专用的串行到并行转换器，具有特定的时钟和逻辑特性，旨在促进高速源同步应用程序的实现。ISERDESE2避免了在FPGA结构中设计反序列化器时遇到的额外定时复杂性。\n\nISERDESE2是Xilinx提供的一个用于串并转换的原语，支持高速数据传输，而不需要特殊FPGA布线来满足数据频率要求，总结来收就是ZYNQ的PL资源中一个特殊的模块，是专门用于高速数据解串的。在代码中例化它之后你可以在综合布线完成之后的芯片资源使用情况中看到它。\n它可以将串行数据转换为并行数据，支持SDR和DDR输入，ISERDESE2可以配置为2、3、4、5、6、7、8、10，14的数据宽度。其中10和14位数据宽度需要使用两个ISERDESE2原语并联实现。\n同时，允许用户动态调整移位，即如果解码结果出现错位，可以动态调整移位，从而实现数据对齐。这个功能由bitslip子模块实现。\nISERDESE2模块的输入输出如下图所示：\n\n篇幅有限，具体引脚功能请参考ug471手册。\n3.4 代码实现\n待更新\n回到顶部\n","categories":["嵌入式","FPGA"],"tags":["zynq","adc"]},{"title":"欢迎来到我的博客！","url":"/2025/11/05/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA/","content":"🚧🚧🚧🚧🚧🚧\n文章列表：\nZYNQ项目开发指南\n"},{"title":"硬件设计从入门到开门","url":"/2023/10/18/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%80%E9%97%A8/","content":"硬件设计从入门到开门\n通信\n串口\n简介\n芯片\n\n\nCH340C\n\n国产芯片\n外围器件少\n双列SOP16封装\n焊接难度小\n占板面积大\n便宜\n\n\n\nCP2102\n\n国外芯片\nQFN封装\n外围器件少\n占板面积小\n焊接难度大\n贵\n\n\n\n\n电源\nLDO\n\n\nRT9012\n\n双通道输出\n带使能端\n300mA输出能力\n\n\n\nRT9013\n\n单通道输出能力\n500mA输出能力\n\n\n\nDC-DC\nBUCK降压\n简介\n芯片\n\n\nSY8088AAC\n特性：\n\n\n2.5 ~ 5.5V输入电压\n\n\n40uA静态电流\n\n\n最高1A电流输出\n\n\nEN使能上升阈值最低电压1.5V\n\n\nSOT23-5封装\n\n\n\n\n\n\n\nSY8089AAC\n特性：\n\n\n2.7 ~ 5.5V输入电压\n\n\n最高2A持续电流输出\n\n\nEN使能上升阈值最低电压1.5V\n\n\nSOT23-5封装\n\n\n\n\n\n\n\nMT3520B\n特性：\n\n\n最高96%效率\n\n\n最高2A持续电流\n\n\n40uA静态电流\n\n\n最低输出0.6V\n\n\n2.3 ~ 6V输入电压\n\n\nSOT23-5封装\n\n\nEN使能阈值1.5V\n\n\nEN失能阈值0.3V\n\n\n\n\n\n\n\nTLV62569\n特性：\n\n\n2.5 ~ 5.5V输入电压\n\n\n35uA静态电流\n\n\n最高2A输出电流\n\n\nEN使能典型阈值0.95V\n\n\n软起动时间800us\n\n\n\n\nBOOST升压\nBUCK-BOOST降压升压\n","categories":["硬件","芯片"]}]